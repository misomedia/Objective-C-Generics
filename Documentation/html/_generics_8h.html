<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Generics Framework: Generics.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Generics Framework
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Generics.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>has Haskelly goodness for all! All code examples come from Haskell's Prelude module.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#import &lt;Foundation/Foundation.h&gt;</code><br/>
<code>#import &lt;Generics/NSArray+Generics.h&gt;</code><br/>
<code>#import &lt;Generics/NSDictionary+Generics.h&gt;</code><br/>
<code>#import &lt;Generics/NSDictionary+Morphism.h&gt;</code><br/>
</div>
<p><a href="_generics_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af67111c10dac3801a9fd3865e2692ee6"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#af67111c10dac3801a9fd3865e2692ee6">map</a> (id(^function)(id x), NSArray *preimage)</td></tr>
<tr class="memdesc:af67111c10dac3801a9fd3865e2692ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic map function.  <a href="#af67111c10dac3801a9fd3865e2692ee6"></a><br/></td></tr>
<tr class="memitem:a41dfdc2943f17a6e8b22873b13f3a661"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#a41dfdc2943f17a6e8b22873b13f3a661">mapWithSelector</a> (SEL selector, NSArray *preimage)</td></tr>
<tr class="memdesc:a41dfdc2943f17a6e8b22873b13f3a661"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic-ish map function.  <a href="#a41dfdc2943f17a6e8b22873b13f3a661"></a><br/></td></tr>
<tr class="memitem:a5a6771307289be1481eee31efde8b5f6"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#a5a6771307289be1481eee31efde8b5f6">mapTuples</a> (NSArray *functionsTuple, NSArray *tuples)</td></tr>
<tr class="memdesc:a5a6771307289be1481eee31efde8b5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication from the left using a row vector of functions, using cons instead of plus and function application as multiplication.  <a href="#a5a6771307289be1481eee31efde8b5f6"></a><br/></td></tr>
<tr class="memitem:a01f5bcd022752653d4e855788121c88a"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#a01f5bcd022752653d4e855788121c88a">mapTuplesWithSelector</a> (SEL *selectorsTuple, NSArray *tuples)</td></tr>
<tr class="memdesc:a01f5bcd022752653d4e855788121c88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as mapTuples but using a C array of selectors instead of an NSArray of blocks.  <a href="#a01f5bcd022752653d4e855788121c88a"></a><br/></td></tr>
<tr class="memitem:af2b68e3de43d9f823cf7300c63a07624"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#af2b68e3de43d9f823cf7300c63a07624">filter</a> (bool(^predicate)(id x), NSArray *feed)</td></tr>
<tr class="memdesc:af2b68e3de43d9f823cf7300c63a07624"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic filter function.  <a href="#af2b68e3de43d9f823cf7300c63a07624"></a><br/></td></tr>
<tr class="memitem:a9c2c6450dd3cfe8b9d2aaadd3bf3544b"><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#a9c2c6450dd3cfe8b9d2aaadd3bf3544b">foldl</a> (id(^function)(id lhs, id rhs), id zero, NSArray *list)</td></tr>
<tr class="memdesc:a9c2c6450dd3cfe8b9d2aaadd3bf3544b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic foldl function.  <a href="#a9c2c6450dd3cfe8b9d2aaadd3bf3544b"></a><br/></td></tr>
<tr class="memitem:ad715313e76fce6db25ab8e4a105f5e10"><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#ad715313e76fce6db25ab8e4a105f5e10">foldr</a> (id(^function)(id lhs, id rhs), id zero, NSArray *list)</td></tr>
<tr class="memdesc:ad715313e76fce6db25ab8e4a105f5e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic foldr function.  <a href="#ad715313e76fce6db25ab8e4a105f5e10"></a><br/></td></tr>
<tr class="memitem:a223119a33050c1e233e7d7239692e11a"><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#a223119a33050c1e233e7d7239692e11a">foldl1</a> (id(^function)(id lhs, id rhs), NSArray *nonemptyList)</td></tr>
<tr class="memdesc:a223119a33050c1e233e7d7239692e11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic foldl1 function.  <a href="#a223119a33050c1e233e7d7239692e11a"></a><br/></td></tr>
<tr class="memitem:a4b6fe20f1cfcfc6b73fd579e42cc546d"><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#a4b6fe20f1cfcfc6b73fd579e42cc546d">foldr1</a> (id(^function)(id lhs, id rhs), NSArray *nonemptyList)</td></tr>
<tr class="memdesc:a4b6fe20f1cfcfc6b73fd579e42cc546d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic foldr1 function.  <a href="#a4b6fe20f1cfcfc6b73fd579e42cc546d"></a><br/></td></tr>
<tr class="memitem:a90be7fdd6620a330bca7da0a6100a811"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#a90be7fdd6620a330bca7da0a6100a811">zip</a> (NSArray *lhsList, NSArray *rhsList)</td></tr>
<tr class="memdesc:a90be7fdd6620a330bca7da0a6100a811"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic zip function.  <a href="#a90be7fdd6620a330bca7da0a6100a811"></a><br/></td></tr>
<tr class="memitem:ae7127ae29c830f646bc9ea3863776fa6"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#ae7127ae29c830f646bc9ea3863776fa6">zipWith</a> (id(^zipper)(id lhs, id rhs), NSArray *lhsList, NSArray *rhsList)</td></tr>
<tr class="memdesc:ae7127ae29c830f646bc9ea3863776fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic zipWith function.  <a href="#ae7127ae29c830f646bc9ea3863776fa6"></a><br/></td></tr>
<tr class="memitem:af1b2a3f7da1e25e04756396d4ffdc3d9"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#af1b2a3f7da1e25e04756396d4ffdc3d9">unzip</a> (NSArray *pairs)</td></tr>
<tr class="memdesc:af1b2a3f7da1e25e04756396d4ffdc3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic unzip function.  <a href="#af1b2a3f7da1e25e04756396d4ffdc3d9"></a><br/></td></tr>
<tr class="memitem:a7f53c521d770d7039c577fbd9300797b"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#a7f53c521d770d7039c577fbd9300797b">flatten</a> (NSArray *arrays)</td></tr>
<tr class="memdesc:a7f53c521d770d7039c577fbd9300797b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic flatten function.  <a href="#a7f53c521d770d7039c577fbd9300797b"></a><br/></td></tr>
<tr class="memitem:a695de152adb86747ad6630e327d92995"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a695de152adb86747ad6630e327d92995"></a>
NSDictionary *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#a695de152adb86747ad6630e327d92995">inverseImageArraysByProjectionWithBlock</a> (NSArray *array, id(^projectionBlock)(id))</td></tr>
<tr class="memdesc:a695de152adb86747ad6630e327d92995"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function which takes an array of objects and returns a dictionary whose keys are the results of applying projectionBlock to the objects in the array and whose objects are the lists of objects from the original array with the same projection, in the order in which they came from the original array. <br/></td></tr>
<tr class="memitem:a788ba4f071db729e24e98832c4ec59ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a788ba4f071db729e24e98832c4ec59ff"></a>
NSDictionary *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#a788ba4f071db729e24e98832c4ec59ff">inverseImageArraysByProjectionWithSelector</a> (NSArray *array, SEL projectionSelector)</td></tr>
<tr class="memdesc:a788ba4f071db729e24e98832c4ec59ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function which takes an array of objects and returns a dictionary whose keys are the results of sending projectionSelector to the objects in the array and whose objects are the lists of objects from the original array with the same projection, in the order in which they came from the original array. <br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa39f6e878780617130104cd73b9cbd6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa39f6e878780617130104cd73b9cbd6d"></a>
id(^&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generics_8h.html#aa39f6e878780617130104cd73b9cbd6d">id_function</a> )(id)</td></tr>
<tr class="memdesc:aa39f6e878780617130104cd73b9cbd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">id function. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>has Haskelly goodness for all! All code examples come from Haskell's Prelude module. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="af2b68e3de43d9f823cf7300c63a07624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSArray* <a class="el" href="_generics_8h.html#af2b68e3de43d9f823cf7300c63a07624">filter</a> </td>
          <td>(</td>
          <td class="paramtype">bool(^)(id x)&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>feed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic filter function. </p>
<div class="fragment"><pre class="fragment">   filter takes a predicate (bool typed function of a single argument of variable type using blocks) and a list (NSArray*).
   It returns the elements of the list, in order, which satisfy the predicate.

   In Haskell:
</pre></div> <div class="fragment"><pre class="fragment">        <a class="code" href="_generics_8h.html#af2b68e3de43d9f823cf7300c63a07624" title="A generic filter function.">filter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
        filter p []                 = []
        filter p (x:xs) | p x       = x : <a class="code" href="_generics_8h.html#af2b68e3de43d9f823cf7300c63a07624" title="A generic filter function.">filter</a> p xs
                                        | otherwise = <a class="code" href="_generics_8h.html#af2b68e3de43d9f823cf7300c63a07624" title="A generic filter function.">filter</a> p xs
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>the predicate as a bool typed function of a single argument of variable type using blocks. </td></tr>
    <tr><td class="paramname">feed</td><td>the feed as an NSArray*. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f53c521d770d7039c577fbd9300797b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSArray* <a class="el" href="_generics_8h.html#a7f53c521d770d7039c577fbd9300797b">flatten</a> </td>
          <td>(</td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic flatten function. </p>
<p>flatten takes a list of lists (of lists...) and removes the (outermost layer of) inner square brackets. </p>

</div>
</div>
<a class="anchor" id="a9c2c6450dd3cfe8b9d2aaadd3bf3544b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id <a class="el" href="_generics_8h.html#a9c2c6450dd3cfe8b9d2aaadd3bf3544b">foldl</a> </td>
          <td>(</td>
          <td class="paramtype">id(^)(id lhs, id rhs)&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id&#160;</td>
          <td class="paramname"><em>zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic foldl function. </p>
<div class="fragment"><pre class="fragment">   foldl takes, as arguments, a function (variably typed function of two arguments of variable type using blocks), a (metaphorically) zero value (id), and an list (NSArray*).
   If the list is empty, it returns the zero value.
   Otherwise, it applies foldl to the function, the result of applying the function to the zero value (on the left) and the head of the list (on the right), and the tail of the list.

   In Haskell:
</pre></div> <div class="fragment"><pre class="fragment">        <a class="code" href="_generics_8h.html#a9c2c6450dd3cfe8b9d2aaadd3bf3544b" title="A generic foldl function.">foldl</a>            :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
        foldl f z []     =  z
        foldl f z (x:xs) =  <a class="code" href="_generics_8h.html#a9c2c6450dd3cfe8b9d2aaadd3bf3544b" title="A generic foldl function.">foldl</a> f (f z x) xs
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the functional argument as a variably typed function of two arguments of variable type using blocks. </td></tr>
    <tr><td class="paramname">zero</td><td>the zero. </td></tr>
    <tr><td class="paramname">list</td><td>the list as an NSArray*. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a223119a33050c1e233e7d7239692e11a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id <a class="el" href="_generics_8h.html#a223119a33050c1e233e7d7239692e11a">foldl1</a> </td>
          <td>(</td>
          <td class="paramtype">id(^)(id lhs, id rhs)&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>nonemptyList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic foldl1 function. </p>
<div class="fragment"><pre class="fragment">   foldl1 takes, as arguments, a function (variably typed function of two arguments of variable type using blocks), and a nonempty list (NSArray*).
   It returns the result of applying foldl to the function, the head of the list, and the tail of the list.

   In Haskell:
</pre></div> <div class="fragment"><pre class="fragment">        <a class="code" href="_generics_8h.html#a223119a33050c1e233e7d7239692e11a" title="A generic foldl1 function.">foldl1</a>           :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a
        foldl1 f (x:xs)  =  <a class="code" href="_generics_8h.html#a9c2c6450dd3cfe8b9d2aaadd3bf3544b" title="A generic foldl function.">foldl</a> f x xs
        <a class="code" href="_generics_8h.html#a223119a33050c1e233e7d7239692e11a" title="A generic foldl1 function.">foldl1</a> _ []      =  error <span class="stringliteral">&quot;Prelude.foldl1: empty list&quot;</span>
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the functional argument as a variably typed function of two arguments of variable type using blocks. </td></tr>
    <tr><td class="paramname">nonemptyList</td><td>the nonempty list as an NSArray*. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad715313e76fce6db25ab8e4a105f5e10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id <a class="el" href="_generics_8h.html#ad715313e76fce6db25ab8e4a105f5e10">foldr</a> </td>
          <td>(</td>
          <td class="paramtype">id(^)(id lhs, id rhs)&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id&#160;</td>
          <td class="paramname"><em>zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic foldr function. </p>
<div class="fragment"><pre class="fragment">   foldr takes, as arguments, a function (variably typed function of two arguments of variable type using blocks), a zero value (id), and a list (NSArray*).
   If the list is empty, it returns the zero value.
   Otherwise, it returns result of applying the function to the head of the list (on the left) and the result of applying foldr to the function, the zero value, and the tail of the list.

   In Haskell:
</pre></div> <div class="fragment"><pre class="fragment">        <a class="code" href="_generics_8h.html#ad715313e76fce6db25ab8e4a105f5e10" title="A generic foldr function.">foldr</a>            :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
        foldr f z []     =  z
        foldr f z (x:xs) =  f x (foldr f z xs)
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the functional argument as a variably typed function of two arguments of variable type using blocks. </td></tr>
    <tr><td class="paramname">zero</td><td>the zero. </td></tr>
    <tr><td class="paramname">list</td><td>the list as an NSArray*. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b6fe20f1cfcfc6b73fd579e42cc546d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id <a class="el" href="_generics_8h.html#a4b6fe20f1cfcfc6b73fd579e42cc546d">foldr1</a> </td>
          <td>(</td>
          <td class="paramtype">id(^)(id lhs, id rhs)&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>nonemptyList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic foldr1 function. </p>
<div class="fragment"><pre class="fragment">   foldr1 takes, as arguments, a function (variably typed function of two arguments of variable type using blocks), and a nonempty list (NSArray*).
   If the nonempty list is of length one, it returns the single item in the list.
   Otherwise it returns the result of applying the function to the head of the list and the result of applying foldr1 to the function and the tail of the list.

   In Haskell:
</pre></div> <div class="fragment"><pre class="fragment">        <a class="code" href="_generics_8h.html#a4b6fe20f1cfcfc6b73fd579e42cc546d" title="A generic foldr1 function.">foldr1</a>           :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a
        foldr1 f [x]     =  x
        foldr1 f (x:xs)  =  f x (foldr1 f xs)
        <a class="code" href="_generics_8h.html#a4b6fe20f1cfcfc6b73fd579e42cc546d" title="A generic foldr1 function.">foldr1</a> _ []      =  error <span class="stringliteral">&quot;Prelude.foldr1: empty list&quot;</span>
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the functional argument as a variably typed function of two arguments of variable type using blocks. </td></tr>
    <tr><td class="paramname">nonemptyList</td><td>the nonempty list as an NSArray*. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af67111c10dac3801a9fd3865e2692ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSArray* <a class="el" href="_generics_8h.html#af67111c10dac3801a9fd3865e2692ee6">map</a> </td>
          <td>(</td>
          <td class="paramtype">id(^)(id x)&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>preimage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic map function. </p>
<div class="fragment"><pre class="fragment">   map takes, as arguments, a function (variably typed function of a single argument of variable type using blocks) and an preimage list (NSArray*).
   It returns an image list containing the images of the elements of the original list under the function.

   In Haskell:
</pre></div> <div class="fragment"><pre class="fragment">        <a class="code" href="_generics_8h.html#af67111c10dac3801a9fd3865e2692ee6" title="A generic map function.">map</a> :: (a -&gt; b) -&gt; [a] -&gt; [b]
        map f []     = []
        map f (x:xs) = f x : <a class="code" href="_generics_8h.html#af67111c10dac3801a9fd3865e2692ee6" title="A generic map function.">map</a> f xs
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the functional argument as a variably typed function of a single argument of variable type using blocks. </td></tr>
    <tr><td class="paramname">preimage</td><td>the preimage as an NSArray*. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a6771307289be1481eee31efde8b5f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSArray* <a class="el" href="_generics_8h.html#a5a6771307289be1481eee31efde8b5f6">mapTuples</a> </td>
          <td>(</td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>functionsTuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>tuples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matrix multiplication from the left using a row vector of functions, using cons instead of plus and function application as multiplication. </p>
<p>mapTuples takes an n-tuple of functions (NSArray*) and a list of n-tuples (NSArray*) and performs matrix multiplication treating the functions tuple as a row vector</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functionsTuple</td><td>the n-tuple of functions as an NSArray* of blocks. </td></tr>
    <tr><td class="paramname">tuples</td><td>the list of n-tuple arguments to the functions as an NSArray* of NSArray*s. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01f5bcd022752653d4e855788121c88a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSArray* <a class="el" href="_generics_8h.html#a01f5bcd022752653d4e855788121c88a">mapTuplesWithSelector</a> </td>
          <td>(</td>
          <td class="paramtype">SEL *&#160;</td>
          <td class="paramname"><em>selectorsTuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>tuples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as mapTuples but using a C array of selectors instead of an NSArray of blocks. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">selectorsTuple</td><td>the n-tuple of functions as a C array of selectors. </td></tr>
    <tr><td class="paramname">tuples</td><td>the list of n-tuple arguments to the functions as an NSArray* of NSArray*s. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41dfdc2943f17a6e8b22873b13f3a661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSArray* <a class="el" href="_generics_8h.html#a41dfdc2943f17a6e8b22873b13f3a661">mapWithSelector</a> </td>
          <td>(</td>
          <td class="paramtype">SEL&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>preimage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic-ish map function. </p>
<p>mapWithSelector does the same thing as map, but with an Objective-C selector (to be used by the runtime) in place of a function. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>the functional argument as a selector. </td></tr>
    <tr><td class="paramname">preimage</td><td>the preimage as an NSArray*. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1b2a3f7da1e25e04756396d4ffdc3d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSArray* <a class="el" href="_generics_8h.html#af1b2a3f7da1e25e04756396d4ffdc3d9">unzip</a> </td>
          <td>(</td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic unzip function. </p>
<div class="fragment"><pre class="fragment">   unzip takes a list of pairs and returns a pair of lists.
   In Haskell:
</pre></div> <div class="fragment"><pre class="fragment">        <a class="code" href="_generics_8h.html#af1b2a3f7da1e25e04756396d4ffdc3d9" title="A generic unzip function.">unzip</a>            :: [(a,b)] -&gt; ([a],[b])
        <a class="code" href="_generics_8h.html#af1b2a3f7da1e25e04756396d4ffdc3d9" title="A generic unzip function.">unzip</a>            =  <a class="code" href="_generics_8h.html#ad715313e76fce6db25ab8e4a105f5e10" title="A generic foldr function.">foldr</a> (\(a,b) ~(as,bs) -&gt; (a:as,b:bs)) ([],[])
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>the list of pairs (NSArray* instances with length-2 NSArray* instances as objects). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90be7fdd6620a330bca7da0a6100a811"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSArray* <a class="el" href="_generics_8h.html#a90be7fdd6620a330bca7da0a6100a811">zip</a> </td>
          <td>(</td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>lhsList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>rhsList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic zip function. </p>
<div class="fragment"><pre class="fragment">   zip takes, as arguments, two lists (NSArray* instances).
   It returns a list of the pairs where the first element in each pair comes from the first list and the second element in each pair comes from the second list.
   NSArrays of length 2 are used for pairs (Objective-C doesn't have tuples, and NSArray* works for all tuple types).

   In Haskell:
</pre></div> <div class="fragment"><pre class="fragment">        <a class="code" href="_generics_8h.html#a90be7fdd6620a330bca7da0a6100a811" title="A generic zip function.">zip</a>              :: [a] -&gt; [b] -&gt; [(a,b)]
        zip              =  zipWith (,)
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhsList</td><td>the list of values to be used as first elements in the pairs in the result. </td></tr>
    <tr><td class="paramname">rhsList</td><td>the list of values to be used as second elements in the pairs in the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7127ae29c830f646bc9ea3863776fa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSArray* <a class="el" href="_generics_8h.html#ae7127ae29c830f646bc9ea3863776fa6">zipWith</a> </td>
          <td>(</td>
          <td class="paramtype">id(^)(id lhs, id rhs)&#160;</td>
          <td class="paramname"><em>zipper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>lhsList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NSArray *&#160;</td>
          <td class="paramname"><em>rhsList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A generic zipWith function. </p>
<div class="fragment"><pre class="fragment">   zipWith takes, as arguments, a zipper function (variably typed function of two arguments of variable type using blocks), and two lists (NSArray* instances).
   It returns a list of the results of applying the zipper function to each pair of elements with equal index in each list.

   In Haskell:
</pre></div> <div class="fragment"><pre class="fragment">        <a class="code" href="_generics_8h.html#ae7127ae29c830f646bc9ea3863776fa6" title="A generic zipWith function.">zipWith</a>          :: (a-&gt;b-&gt;c) -&gt; [a]-&gt;[b]-&gt;[c]
        zipWith z (a:as) (b:bs)
                                         =  z a b : zipWith z as bs
        zipWith _ _ _    =  []
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">zipper</td><td>the zipper function as a variably typed function of two arguments of variable type using blocks. </td></tr>
    <tr><td class="paramname">lhsList</td><td>the list of values to be used as the lhs argument when forming the result. </td></tr>
    <tr><td class="paramname">rhsList</td><td>the list of values to be used as the rhs argument when forming the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 27 2012 12:42:16 for Generics Framework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
